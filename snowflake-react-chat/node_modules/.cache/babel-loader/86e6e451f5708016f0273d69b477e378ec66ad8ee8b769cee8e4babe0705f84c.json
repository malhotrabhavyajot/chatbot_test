{"ast":null,"code":"// src/api/snowflake.js\n\nconst SNOWFLAKE_URL = \"https://otsuka_ctdev.us-east-1.snowflakecomputing.com\";\n\n// Optionally: fallback token provider if the main one fails/refreshes\nasync function fetchTokenFromRender() {\n  try {\n    const res = await fetch(\"https://project-f3vi.onrender.com/generate_jwt\");\n    const data = await res.json();\n    return data.token;\n  } catch (error) {\n    console.error(\"Failed to fetch token from Render:\", error);\n    return null;\n  }\n}\nasync function callSnowflake(statement, token) {\n  const response = await fetch(`${SNOWFLAKE_URL}/api/v2/statements`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${token}`\n    },\n    body: JSON.stringify({\n      statement: `CALL CUSTOM_AGENT('${statement}')`,\n      role: \"MSTR_READER_ROLE\",\n      warehouse: \"MSTR_M_WH\",\n      database: \"CDR\",\n      schema: \"CDR_RPT\"\n    })\n  });\n  return response;\n}\n\n// Main function: handles token fallback and parses results\nexport async function sendToSnowflakeAPI(message, initialToken) {\n  let token = initialToken;\n  let response = await callSnowflake(message, token);\n\n  // Fallback if token expired/unauthorized\n  if (response.status === 401 || response.status === 403) {\n    token = await fetchTokenFromRender();\n    if (!token) return \"Error: Unable to refresh token.\";\n    response = await callSnowflake(message, token);\n  }\n  const rawText = await response.text();\n  let extractedTexts = [];\n  const lines = rawText.split(\"\\n\");\n  for (const line of lines) {\n    if (line.startsWith('  \"data\" : [ [')) {\n      try {\n        const rawLine = line.replace('  \"data\" : ', \"\").replace('[ [', '[[').replaceAll(\"'\", \"\").replace('] ],', ']]');\n        const dataArray = JSON.parse(rawLine);\n        const innerString = dataArray[0][0];\n        const fixedJsonString = innerString.replace(/'/g, '\"').replace(/None/g, 'null').replace(/\\bTrue\\b/g, 'true').replace(/\\bFalse\\b/g, 'false');\n        const parsedObject = JSON.parse(fixedJsonString);\n        extractedTexts.push(parsedObject.output);\n      } catch (error) {}\n    }\n  }\n  if (extractedTexts.length > 0) return extractedTexts.join(\" \");\n  return \"No results.\";\n}","map":{"version":3,"names":["SNOWFLAKE_URL","fetchTokenFromRender","res","fetch","data","json","token","error","console","callSnowflake","statement","response","method","headers","Authorization","body","JSON","stringify","role","warehouse","database","schema","sendToSnowflakeAPI","message","initialToken","status","rawText","text","extractedTexts","lines","split","line","startsWith","rawLine","replace","replaceAll","dataArray","parse","innerString","fixedJsonString","parsedObject","push","output","length","join"],"sources":["/workspaces/chatbot_test/snowflake-react-chat/src/api/snowflake.js"],"sourcesContent":["// src/api/snowflake.js\n\nconst SNOWFLAKE_URL = \"https://otsuka_ctdev.us-east-1.snowflakecomputing.com\";\n\n\n// Optionally: fallback token provider if the main one fails/refreshes\nasync function fetchTokenFromRender() {\n  try {\n    const res = await fetch(\"https://project-f3vi.onrender.com/generate_jwt\");\n    const data = await res.json();\n    return data.token;\n  } catch (error) {\n    console.error(\"Failed to fetch token from Render:\", error);\n    return null;\n  }\n}\n\nasync function callSnowflake(statement, token) {\n  const response = await fetch(`${SNOWFLAKE_URL}/api/v2/statements`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${token}`,\n    },\n    body: JSON.stringify({\n      statement: `CALL CUSTOM_AGENT('${statement}')`,\n      role: \"MSTR_READER_ROLE\",\n      warehouse: \"MSTR_M_WH\",\n      database: \"CDR\",\n      schema: \"CDR_RPT\"\n    }),\n  });\n  return response;\n}\n\n// Main function: handles token fallback and parses results\nexport async function sendToSnowflakeAPI(message, initialToken) {\n  let token = initialToken;\n  let response = await callSnowflake(message, token);\n\n  // Fallback if token expired/unauthorized\n  if (response.status === 401 || response.status === 403) {\n    token = await fetchTokenFromRender();\n    if (!token) return \"Error: Unable to refresh token.\";\n    response = await callSnowflake(message, token);\n  }\n\n  const rawText = await response.text();\n  let extractedTexts = [];\n\n  const lines = rawText.split(\"\\n\");\n  for (const line of lines) {\n    if (line.startsWith('  \"data\" : [ [')) {\n      try {\n        const rawLine = line.replace('  \"data\" : ', \"\").replace('[ [', '[[').replaceAll(\"'\", \"\").replace('] ],', ']]');\n        const dataArray = JSON.parse(rawLine);\n        const innerString = dataArray[0][0];\n        const fixedJsonString = innerString\n          .replace(/'/g, '\"')\n          .replace(/None/g, 'null')\n          .replace(/\\bTrue\\b/g, 'true')\n          .replace(/\\bFalse\\b/g, 'false');\n        const parsedObject = JSON.parse(fixedJsonString);\n        extractedTexts.push(parsedObject.output);\n      } catch (error) {\n\n      }\n    }\n  }\n\n  if (extractedTexts.length > 0) return extractedTexts.join(\" \");\n\n  return \"No results.\";\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}